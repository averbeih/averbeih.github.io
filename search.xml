<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>安洵杯密码复现</title>
      <link href="/2023/12/24/%E5%AE%89%E6%B4%B5%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/12/24/%E5%AE%89%E6%B4%B5%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>密码1：<br>task</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import hashlib</span><br><span class="line">import socketserver</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes, getStrongPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">flag = b&quot;D0g3&#123;******************************************&#125;&quot;</span><br><span class="line"></span><br><span class="line">class MyServer(socketserver.BaseRequestHandler):</span><br><span class="line">    def proof(self):</span><br><span class="line">        random.seed(os.urandom(8))</span><br><span class="line">        random_str = &#x27;&#x27;.join([random.choice(string.ascii_letters + string.digits) for _ in range(20)])</span><br><span class="line">        str_sha256 = hashlib.sha256(random_str.encode()).hexdigest()</span><br><span class="line">        self.request.sendall((&#x27;SHA256(XXXX + %s):%s\n&#x27; % (random_str[4:], str_sha256)).encode())</span><br><span class="line">        self.request.sendall(&#x27;Give Me XXXX:\n&#x27;.encode())</span><br><span class="line">        XXXX = self.request.recv(2048).strip()</span><br><span class="line"></span><br><span class="line">        if hashlib.sha256((XXXX + random_str[4:].encode())).hexdigest() != str_sha256:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def getPQN(self):</span><br><span class="line">        while True:</span><br><span class="line">            p = getStrongPrime(2048)</span><br><span class="line">            q = getStrongPrime(2048)</span><br><span class="line">            n = p * q</span><br><span class="line">            if p.bit_length() == 2048 and q.bit_length() == 2048 and n.bit_length() == 4096:</span><br><span class="line">                return p, q, n</span><br><span class="line"></span><br><span class="line">    def encrypt(self):</span><br><span class="line">        p, q, n = self.getPQN()</span><br><span class="line">        m = bytes_to_long(flag)</span><br><span class="line">        e = 0x10001</span><br><span class="line">        c = pow(m, e, n)</span><br><span class="line">        p = bin(p)[2:]</span><br><span class="line">        p1 = list(p[:1024])</span><br><span class="line">        p2 = list(p[1024:])</span><br><span class="line">        p1[random.choice([i for i, c in enumerate(p1) if c == &#x27;1&#x27;])] = &#x27;0&#x27;</span><br><span class="line">        p2[random.choice([i for i, c in enumerate(p1) if c == &#x27;0&#x27;])] = &#x27;1&#x27;</span><br><span class="line">        return n, &#x27;&#x27;.join(p1) + &#x27;&#x27;.join(p2), c</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        if not self.proof():</span><br><span class="line">            self.request.sendall(b&#x27;Error Hash!&#x27;)</span><br><span class="line">            return</span><br><span class="line">        n, p, c = self.encrypt()</span><br><span class="line">        self.request.sendall(&#x27;Press 1 to get ciphertext\n&#x27;.encode())</span><br><span class="line">        number = self.request.recv(512).strip().decode()</span><br><span class="line">        if number == &#x27;1&#x27;:</span><br><span class="line">            self.request.sendall((str(n) + &#x27;\n&#x27;).encode())</span><br><span class="line">            self.request.sendall((str(p) + &#x27;\n&#x27;).encode())</span><br><span class="line">            self.request.sendall((str(c) + &#x27;\n&#x27;).encode())</span><br><span class="line">        else:</span><br><span class="line">            self.request.sendall(&#x27;Incorrect input!\n&#x27;.encode())</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    sever = socketserver.ThreadingTCPServer((&#x27;0.0.0.0&#x27;, 10001), MyServer)</span><br><span class="line">    ThreadedTCPServer.allow_reuse_address = True</span><br><span class="line">    ThreadedTCPServer.allow_reuse_port = True</span><br><span class="line">    sever.serve_forever()</span><br></pre></td></tr></table></figure><p>第一步 ，我们需要连接靶机<br>与靶机交互即可得到一串hash，爆破前4位使字符串的hash256与题目所给的一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">target_hash = &quot;e7d00e85945e40298e71766df1134d7df4c33def9ded64389e541c50e689870e&quot;</span><br><span class="line"></span><br><span class="line">for char_1 in range(48, 123):  # ASCII码中数字、大写字母和小写字母的范围</span><br><span class="line">    for char_2 in range(48, 123):</span><br><span class="line">        for char_3 in range(48, 123):</span><br><span class="line">            for char_4 in range(48, 123):</span><br><span class="line">                if len(&#123;char_1, char_2, char_3, char_4&#125;) == 4:  # 确保四个字符都是不同的</span><br><span class="line">                    ascii_chars = (chr(char_1), chr(char_2), chr(char_3), chr(char_4))</span><br><span class="line">                    combination = &quot;&quot;.join(ascii_chars) + &#x27;mw21BZK89qImQVZX&#x27;  # 在每个组合后添加特定字符串</span><br><span class="line"></span><br><span class="line">                    # 计算哈希值</span><br><span class="line">                    hash_object = hashlib.sha256()</span><br><span class="line">                    hash_object.update(combination.encode())</span><br><span class="line">                    hashed = hash_object.hexdigest()</span><br><span class="line"></span><br><span class="line">                    # 检查是否匹配目标哈希值</span><br><span class="line">                    if hashed == target_hash:</span><br><span class="line">                        print(&quot;匹配的组合为:&quot;, combination)</span><br><span class="line">                        exit()  # 找到匹配的组合后结束程序运行</span><br><span class="line"></span><br><span class="line">#匹配的组合为: KsAxmw21BZK89qImQVZX</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023强网杯密码复现</title>
      <link href="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Diffie-Hellman的公钥加密</title>
      <link href="/2023/12/12/%E5%9F%BA%E4%BA%8EDiffie-Hellman%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/"/>
      <url>/2023/12/12/%E5%9F%BA%E4%BA%8EDiffie-Hellman%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>在那篇划时代的论文《New Directions in Cryptography》中，作者Diffie和Hellman虽然并没有提出一个实际的公钥密码加密算法，但却提出了一个可以在不安全信道中交换密钥的协议，这个密钥交换协议就是基于离散对数难题的。</p><span id="more"></span><p>Diffie-Hellman密钥交换协议︰</p><p>1.首先通信双方Alice和Bob先共享两个公共参数，模数p和Z<del>p</del>​^*^,中的一个原根g。</p><ol><li>Alice本地随机生成一个私钥a，并计算公钥A &#x3D; g^a^，发送A给Bob</li><li>Bob在收到A后，也本地随机生成一个私钥b，并计算公钥B&#x3D;g^b^，发送B给Alice;此外，Bob还可以计算共享密钥k &#x3D; A^b^ &#x3D; g^ab^</li><li>Alice收到Bob发过来的B后，也可以计算共享密钥k &#x3D; B^a^ &#x3D; g^ab^<br>5．至此，密钥交换结束，双方都可以得到一份共享密钥</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络空间技术协会开始纳新啦！！！</title>
      <link href="/2023/11/30/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A%E5%BC%80%E5%A7%8B%E7%BA%B3%E6%96%B0%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2023/11/30/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A%E5%BC%80%E5%A7%8B%E7%BA%B3%E6%96%B0%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到密码学的世界！！！</p><span id="more"></span><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hint:74686973206973206D643520426F6F6D21</span><br><span class="line"></span><br><span class="line">6cd29f23de85b1309128ff736c7efbf6</span><br><span class="line">efa4e6f5c6359cc2eadc5d731716468e</span><br><span class="line">408a9c4a79800232ac656249af3162eb</span><br><span class="line">6adff50182df8ad3b836f7fb9dc5c4ab</span><br><span class="line">6ae0af41daeb79509ab3b47b5ed8a687</span><br><span class="line"></span><br><span class="line">key:qwertyuiopasdfghjklzxcvbn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
