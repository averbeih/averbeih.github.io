<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习导航</title>
      <link href="/2024/01/11/%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA/"/>
      <url>/2024/01/11/%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到二进制的世界！！！</p><span id="more"></span><p>111</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安洵杯密码复现</title>
      <link href="/2023/12/24/%E5%AE%89%E6%B4%B5%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/12/24/%E5%AE%89%E6%B4%B5%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>安洵杯密码题目分析</p><span id="more"></span><h1 id="密码1："><a href="#密码1：" class="headerlink" title="密码1："></a>密码1：</h1><p><strong>task</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import hashlib</span><br><span class="line">import socketserver</span><br><span class="line">from Crypto.Util.number import isPrime, long_to_bytes, getStrongPrime, bytes_to_long</span><br><span class="line"></span><br><span class="line">flag = b&quot;D0g3&#123;******************************************&#125;&quot;</span><br><span class="line"></span><br><span class="line">class MyServer(socketserver.BaseRequestHandler):</span><br><span class="line">    def proof(self):</span><br><span class="line">        random.seed(os.urandom(8))</span><br><span class="line">        random_str = &#x27;&#x27;.join([random.choice(string.ascii_letters + string.digits) for _ in range(20)])</span><br><span class="line">        str_sha256 = hashlib.sha256(random_str.encode()).hexdigest()</span><br><span class="line">        self.request.sendall((&#x27;SHA256(XXXX + %s):%s\n&#x27; % (random_str[4:], str_sha256)).encode())</span><br><span class="line">        self.request.sendall(&#x27;Give Me XXXX:\n&#x27;.encode())</span><br><span class="line">        XXXX = self.request.recv(2048).strip()</span><br><span class="line"></span><br><span class="line">        if hashlib.sha256((XXXX + random_str[4:].encode())).hexdigest() != str_sha256:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def getPQN(self):</span><br><span class="line">        while True:</span><br><span class="line">            p = getStrongPrime(2048)</span><br><span class="line">            q = getStrongPrime(2048)</span><br><span class="line">            n = p * q</span><br><span class="line">            if p.bit_length() == 2048 and q.bit_length() == 2048 and n.bit_length() == 4096:</span><br><span class="line">                return p, q, n</span><br><span class="line"></span><br><span class="line">    def encrypt(self):</span><br><span class="line">        p, q, n = self.getPQN()</span><br><span class="line">        m = bytes_to_long(flag)</span><br><span class="line">        e = 0x10001</span><br><span class="line">        c = pow(m, e, n)</span><br><span class="line">        p = bin(p)[2:]</span><br><span class="line">        p1 = list(p[:1024])</span><br><span class="line">        p2 = list(p[1024:])</span><br><span class="line">        p1[random.choice([i for i, c in enumerate(p1) if c == &#x27;1&#x27;])] = &#x27;0&#x27;</span><br><span class="line">        p2[random.choice([i for i, c in enumerate(p1) if c == &#x27;0&#x27;])] = &#x27;1&#x27;</span><br><span class="line">        return n, &#x27;&#x27;.join(p1) + &#x27;&#x27;.join(p2), c</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        if not self.proof():</span><br><span class="line">            self.request.sendall(b&#x27;Error Hash!&#x27;)</span><br><span class="line">            return</span><br><span class="line">        n, p, c = self.encrypt()</span><br><span class="line">        self.request.sendall(&#x27;Press 1 to get ciphertext\n&#x27;.encode())</span><br><span class="line">        number = self.request.recv(512).strip().decode()</span><br><span class="line">        if number == &#x27;1&#x27;:</span><br><span class="line">            self.request.sendall((str(n) + &#x27;\n&#x27;).encode())</span><br><span class="line">            self.request.sendall((str(p) + &#x27;\n&#x27;).encode())</span><br><span class="line">            self.request.sendall((str(c) + &#x27;\n&#x27;).encode())</span><br><span class="line">        else:</span><br><span class="line">            self.request.sendall(&#x27;Incorrect input!\n&#x27;.encode())</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    sever = socketserver.ThreadingTCPServer((&#x27;0.0.0.0&#x27;, 10001), MyServer)</span><br><span class="line">    ThreadedTCPServer.allow_reuse_address = True</span><br><span class="line">    ThreadedTCPServer.allow_reuse_port = True</span><br><span class="line">    sever.serve_forever()</span><br></pre></td></tr></table></figure><p><strong>第一步 ，我们需要连接靶机</strong><br><em>与靶机交互即可得到一串hash，爆破前4位使字符串的hash256与题目所给的一致</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">target_hash = &quot;e7d00e85945e40298e71766df1134d7df4c33def9ded64389e541c50e689870e&quot;</span><br><span class="line"></span><br><span class="line">for char_1 in range(48, 123):  # ASCII码中数字、大写字母和小写字母的范围</span><br><span class="line">    for char_2 in range(48, 123):</span><br><span class="line">        for char_3 in range(48, 123):</span><br><span class="line">            for char_4 in range(48, 123):</span><br><span class="line">                if len(&#123;char_1, char_2, char_3, char_4&#125;) == 4:  # 确保四个字符都是不同的</span><br><span class="line">                    ascii_chars = (chr(char_1), chr(char_2), chr(char_3), chr(char_4))</span><br><span class="line">                    combination = &quot;&quot;.join(ascii_chars) + &#x27;mw21BZK89qImQVZX&#x27;  # 在每个组合后添加特定字符串</span><br><span class="line"></span><br><span class="line">                    # 计算哈希值</span><br><span class="line">                    hash_object = hashlib.sha256()</span><br><span class="line">                    hash_object.update(combination.encode())</span><br><span class="line">                    hashed = hash_object.hexdigest()</span><br><span class="line"></span><br><span class="line">                    # 检查是否匹配目标哈希值</span><br><span class="line">                    if hashed == target_hash:</span><br><span class="line">                        print(&quot;匹配的组合为:&quot;, combination)</span><br><span class="line">                        exit()  # 找到匹配的组合后结束程序运行</span><br><span class="line"></span><br><span class="line">#匹配的组合为: KsAxmw21BZK89qImQVZX</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>另一种更快的方法,直接利用pwntools与靶机交互，得到题目</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from hashlib import sha256</span><br><span class="line">import string</span><br><span class="line">from pwnlib.util.iters import mbruteforce</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">r = remote(&quot;124.71.177.14&quot;, 10010)</span><br><span class="line"></span><br><span class="line">table = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line">def pow():</span><br><span class="line">    r.recvuntil(&quot;XXXX + &quot;)</span><br><span class="line">    suffix = r.recv(16).decode(&quot;utf8&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    cipher = r.recvline().strip().decode(&quot;utf8&quot;)</span><br><span class="line">    proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() ==</span><br><span class="line">                        cipher, table, length=4, method=&#x27;fixed&#x27;)</span><br><span class="line">    r.sendline(proof)</span><br><span class="line"></span><br><span class="line">pow()</span><br><span class="line">r.sendline(&#x27;1&#x27;)</span><br><span class="line">r.recvuntil(&#x27;This is your flag: &#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>接下来，靶机会返回一组数据</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">n=689148428917048752698561230187435330535844474535660975519663024686005813423116261691596518960359444398659487569281405280516756122565301499107276527019563398561775190548326726650095124347721633102683517354241616731272290842366644969493523095260169026118700872122205961125840074575539913181179624158591316008961999519664445180765805855068357280325140200570721885619207531433799082034359675994945498536733447149520815614429142224067402920944323350406000139261949314945008134993667106166371729994211490216695953544210086909916594288871041686796264966615061234867849533737850978285759970378711342002735127852669911135633280727507197770896643162828873860290236954478934069039880842775659386156914426681646990123375726632782848318765676209660955746904921591374247548244510795028854167024612141080434153599742660712283405861398644681971440490492676518075438358400296468401567303163631533553410643660848819592904185023897183284947919518254876711845553448295870785376932257813856605607299735796578232939819120320722961149946000934150374343672467868456190855696298746763169171976016018534242348938143398691129090031066272454600059389810619648519400690544893179323782655271245976991844056669848133657162015017534126606913505865717577945680934201</span><br><span class="line">p=11000100010010100101011010011010100110111011101111001100001110011000011100001010101001011000011001100100100001111010100011101001001111100111011000010100100110000010011101111010111001001100100000101101011001100000110101101001111011001101110000100000100001100000100110001001010011000111101111101100101101010111011001101111101011001100111000011111000011101100110001101010000110111001100101011101011100111111010101001110101110110010100000000100001111101001110010101000010011011001100011111111100110011000001010000101101010001001001101010110101111101101111001110100101101101011000010111100100010000111101110001001101111101111110010000111101101000000111111011010011011101101000101000100010001101001011111000111000101101001100110011111100101011110011110110110000110100110001111010001001100011011110001110000001000111100101001000001001011110100101010001111110110110001110110001100101001011110010101010100101011110101010101001000000111010001000100111000011000011101011110101001001001011001011110010010010000010110110010000100100110111100110001011101101100010011110000000011001010010010100010110000000000101010111011011100010010001100000100100110101100011111100011110001001011111101001111000000010000110000111011100000001100111010011000011010001001101011100111000010001010010000000010111000110011100100110101010000000101101101100011110110111101010110011101000001100010011001001001101000000010100100100111010011011001101011011110101100000100011000100101001000010100101100100101000111000001100001001110000011000101000000001011100010011010001111011011001011000011111111101001100111000111110100010101011101100110100001010101101011001110000100100011010010001110111001001110000110100010011000010000011000011111101011011001001111010011100001101010110000110000010100100001011100101001011101010111000001100011110010010101010101100011110101111101101010101011100001001101001000101000100100111000010001100010100101100101000111100000001001110111101110110100010100000001001110011101000011100100010111101110010111101101010010001011010011100011111000011000001100011001100011</span><br><span class="line">c=582755493501376550312021063293971269432622857973591275097520241824639113243678154601039738777785910875356099861877799721721629337353531048570147711682149769656300149663334265982311991206401905216350979684516071937023923185938510050693691337873407171757275643036119429129455102869684317978357782902189346531413458627379268090802106996865349905645096514117275113848528530242217188285324909887937524122208178818340097019103831473349905133558912714201852986162525855145162259280450040753185483478933398530730654529154485769469682628353274080092629445953899362883988215175193630488889635324515092313723195910983168425805177795699565396108348821928449320190783128803002754706992512092839782219348149442008758998793607436136085108333190190347733106486023581643835108125870863346801123024469552193808660738495330000657495372570089643330001020748391509387487524136411478620736071866518379044131693794690230740826475529806050936866355127348429602091123271970724772553111459156824158976033596665391059836828836907988254364980925568575831029223091042575366899359078304670344881979433579570857621141077250931877184312810916773443135402247438937358801349822845162460003198622710136542402567604311023354451215661022609583925197654492145458148760392</span><br></pre></td></tr></table></figure><p><strong>根据源码分析，他把其中的p做了这样一个操作</strong><br>p1[random.choice([i for i, c in enumerate(p1) if c &#x3D;&#x3D; ‘1’)]) &#x3D; ‘0’: 在 p1 的随机位置找到一个为 ‘1’ 的位，并将其改为 ‘0’。<br>p2[random.choice([i for i, c in enumerate(p1) if c &#x3D;&#x3D; ‘0’)]) &#x3D; ‘1’: 在 p2 的随机位置找到一个为 ‘0’ 的位，并将其改为 ‘1’。<br><strong>所以我们只需要根据这个漏洞遍历前1024位的0和后1024位的1进行异或操作即可</strong><br><em>笔者这边直接构造了一个密码本</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Sat Dec 23 14:15:02 2023</span><br><span class="line"></span><br><span class="line">@author: lenovo</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">p= 11000100010010100101011010011010100110111011101111001100001110011000011100001010101001011000011001100100100001111010100011101001001111100111011000010100100110000010011101111010111001001100100000101101011001100000110101101001111011001101110000100000100001100000100110001001010011000111101111101100101101010111011001101111101011001100111000011111000011101100110001101010000110111001100101011101011100111111010101001110101110110010100000000100001111101001110010101000010011011001100011111111100110011000001010000101101010001001001101010110101111101101111001110100101101101011000010111100100010000111101110001001101111101111110010000111101101000000111111011010011011101101000101000100010001101001011111000111000101101001100110011111100101011110011110110110000110100110001111010001001100011011110001110000001000111100101001000001001011110100101010001111110110110001110110001100101001011110010101010100101011110101010101001000000111010001000100111000011000011101011110101001001001011001011110010010010000010110110010000100100110111100110001011101101100010011110000000011001010010010100010110000000000101010111011011100010010001100000100100110101100011111100011110001001011111101001111000000010000110000111011100000001100111010011000011010001001101011100111000010001010010000000010111000110011100100110101010000000101101101100011110110111101010110011101000001100010011001001001101000000010100100100111010011011001101011011110101100000100011000100101001000010100101100100101000111000001100001001110000011000101000000001011100010011010001111011011001011000011111111101001100111000111110100010101011101100110100001010101101011001110000100100011010010001110111001001110000110100010011000010000011000011111101011011001001111010011100001101010110000110000010100100001011100101001011101010111000001100011110010010101010101100011110101111101101010101011100001001101001000101000100100111000010001100010100101100101000111100000001001110111101110110100010100000001001110011101000011100100010111101110010111101101010010001011010011100011111000011000001100011001100011</span><br><span class="line">p1=1100010001001010010101101001101010011011101110111100110000111001100001110000101010100101100001100110010010000111101010001110100100111110011101100001010010011000001001110111101011100100110010000010110101100110000011010110100111101100110111000010000010000110000010011000100101001100011110111110110010110101011101100110111110101100110011100001111100001110110011000110101000011011100110010101110101110011111101010100111010111011001010000000010000111110100111001010100001001101100110001111111110011001100000101000010110101000100100110101011010111110110111100111010010110110101100001011110010001000011110111000100110111110111111001000011110110100000011111101101001101110110100010100010001000110100101111100011100010110100110011001111110010101111001111011011000011010011000111101000100110001101111000111000000100011110010100100000100101111010010101000111111011011000111011000110010100101111001010101010010101111010101010100100000011101000100010011100001100001110101111010100100100101100101111001001001000001011011001000010010011011</span><br><span class="line">p2=1100110001011101101100010011110000000011001010010010100010110000000000101010111011011100010010001100000100100110101100011111100011110001001011111101001111000000010000110000111011100000001100111010011000011010001001101011100111000010001010010000000010111000110011100100110101010000000101101101100011110110111101010110011101000001100010011001001001101000000010100100100111010011011001101011011110101100000100011000100101001000010100101100100101000111000001100001001110000011000101000000001011100010011010001111011011001011000011111111101001100111000111110100010101011101100110100001010101101011001110000100100011010010001110111001001110000110100010011000010000011000011111101011011001001111010011100001101010110000110000010100100001011100101001011101010111000001100011110010010101010101100011110101111101101010101011100001001101001000101000100100111000010001100010100101100101000111100000001001110111101110110100010100000001001110011101000011100100010111101110010111101101010010001011010011100011111000011000001100011001100011</span><br><span class="line"></span><br><span class="line"># 初始二进制数</span><br><span class="line">p1 = &quot;1100111110010000110010010100010101101111101111001100100001111001010011011000000000110110100001001110101101011010101001110011100111001110011011110110101000110111100100010111000110111000100011101000001011011011110101010101011110001111000001010111101100101010101001011011101000110011111000101101001010100011010001000110101111101110011011101111101011110010010010000001010000111001001001100101101111100111111111100101001000011010110010011001000110101011000000100110011001011011101101101001110101011100101111011100011100000101100001001000001001111100001000100010000100100000000111010000100111000000100111000100011001011010001010110011001001001111101100100011100000010111001111001011010011111001010000110100110001010101100111111010011000001000011011000101010110010101010000110111101001010101101110110111010001110011101101111111011111000011010111111111011011111110011101010110000111100011111000100011101101001011111000110011111011000111011101101011110001011010001100101000001111100110111110001010001100110000000111111011010100000111&quot;</span><br><span class="line"></span><br><span class="line"># 创建文件来保存输出结果</span><br><span class="line">output_file = &quot;listp1.txt&quot;</span><br><span class="line"></span><br><span class="line">modified_binaries = []</span><br><span class="line"></span><br><span class="line"># 检查每一位，如果为0则改为1</span><br><span class="line">for i in range(len(p1)):</span><br><span class="line">    if p1[i] == &#x27;0&#x27;:</span><br><span class="line">        modified_p1 = p1[:i] + &#x27;1&#x27; + p1[i+1:]</span><br><span class="line">        modified_binaries.append(modified_p1)</span><br><span class="line"></span><br><span class="line"># 将所有修改后的结果写入文件</span><br><span class="line">with open(output_file, &quot;w&quot;) as file:</span><br><span class="line">    for modified_p1 in modified_binaries:</span><br><span class="line">        file.write(modified_p1 + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 初始二进制数</span><br><span class="line">p2 = &quot;0111110110100110111001011111100001000101010100101001101000110101111111001110110111100010001000001011111000001000010001010010001000001000001100010100001010101110100101000111110111111100000100110011111111100001100010011011101100111010111011111111010000111100001011100000011011011101001010110000110000100011111010001000100110110101011011011101101001010100100011111011100011001010001011110010001011100100111110101010100001111001110010100011111111011010101001011001110100101010101110011010010011010001011001000101110110111101100000000111010000001101101000110010101011101100011011010100000111110011100000101100011001011010101010011010000110000100101010000111010000010000111101011101001110000100001011001000101111111010001111101100111100001111010111000111110000000100101101011100110100010010100110010110111110010101110100100110110111111101101001101001111111000001010010111101011100010001110100001100111100100101000011000010010101110011000001011000100111010001101011010001010001010100010000111100101011010011001001001001010001011111&quot;</span><br><span class="line"></span><br><span class="line"># 创建文件来保存输出结果</span><br><span class="line">output_file = &quot;listp2.txt&quot;</span><br><span class="line"></span><br><span class="line">modified_binaries = []</span><br><span class="line"></span><br><span class="line"># 检查每一位，如果为0则改为1</span><br><span class="line">for i in range(len(p2)):</span><br><span class="line">    if p2[i] == &#x27;0&#x27;:</span><br><span class="line">        modified_p1 = p2[:i] + &#x27;1&#x27; + p2[i+1:]</span><br><span class="line">        modified_binaries.append(modified_p1)</span><br><span class="line"></span><br><span class="line"># 将所有修改后的结果写入文件</span><br><span class="line">with open(output_file, &quot;w&quot;) as file:</span><br><span class="line">    for modified_p1 in modified_binaries:</span><br><span class="line">        file.write(modified_p1 + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开 listp1.txt 和 listp2.txt 文件以及输出文件 p.txt</span><br><span class="line">with open(&#x27;listp1.txt&#x27;, &#x27;r&#x27;) as file1, open(&#x27;listp2.txt&#x27;, &#x27;r&#x27;) as file2, open(&#x27;p.txt&#x27;, &#x27;w&#x27;) as output_file:</span><br><span class="line">    # 逐行读取文件内容</span><br><span class="line">    p1_lines = file1.readlines()</span><br><span class="line">    p2_lines = file2.readlines()</span><br><span class="line"></span><br><span class="line">    # 遍历两个文件中的所有组合并将其写入输出文件</span><br><span class="line">    for p1 in p1_lines:</span><br><span class="line">        file2.seek(0)  # 重新定位到 listp2.txt 文件的开头</span><br><span class="line">        for p2 in p2_lines:</span><br><span class="line">            # 写入组合到输出文件</span><br><span class="line">            output_file.write(f&quot;&#123;p1.strip()&#125;&#123;p2.strip()&#125;\n&quot;)</span><br></pre></td></tr></table></figure><p><em>然后遍历密码本进行rsa解密即可</em><br><strong>这组数据比较特殊，直接爆破的情况下会遇到模不互素的情况</strong><br><em>所以我们代码中加入跳过模不互素的情况即可</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n = 689148428917048752698561230187435330535844474535660975519663024686005813423116261691596518960359444398659487569281405280516756122565301499107276527019563398561775190548326726650095124347721633102683517354241616731272290842366644969493523095260169026118700872122205961125840074575539913181179624158591316008961999519664445180765805855068357280325140200570721885619207531433799082034359675994945498536733447149520815614429142224067402920944323350406000139261949314945008134993667106166371729994211490216695953544210086909916594288871041686796264966615061234867849533737850978285759970378711342002735127852669911135633280727507197770896643162828873860290236954478934069039880842775659386156914426681646990123375726632782848318765676209660955746904921591374247548244510795028854167024612141080434153599742660712283405861398644681971440490492676518075438358400296468401567303163631533553410643660848819592904185023897183284947919518254876711845553448295870785376932257813856605607299735796578232939819120320722961149946000934150374343672467868456190855696298746763169171976016018534242348938143398691129090031066272454600059389810619648519400690544893179323782655271245976991844056669848133657162015017534126606913505865717577945680934201</span><br><span class="line">e = 0x10001</span><br><span class="line"></span><br><span class="line">with open(&#x27;p.txt&#x27;, &#x27;r&#x27;) as p_file:</span><br><span class="line">    for line in p_file:</span><br><span class="line">        p = line.strip()</span><br><span class="line"></span><br><span class="line">        q_candidate = n // int(p, 2)</span><br><span class="line">        if q_candidate * int(p, 2) != n:</span><br><span class="line">            continue  # 如果不能整除，跳过当前行处理</span><br><span class="line"></span><br><span class="line">        phi = (int(p, 2) - 1) * (q_candidate - 1)</span><br><span class="line">        try:</span><br><span class="line">            d = gmpy2.invert(e, phi)</span><br><span class="line">            c = 582755493501376550312021063293971269432622857973591275097520241824639113243678154601039738777785910875356099861877799721721629337353531048570147711682149769656300149663334265982311991206401905216350979684516071937023923185938510050693691337873407171757275643036119429129455102869684317978357782902189346531413458627379268090802106996865349905645096514117275113848528530242217188285324909887937524122208178818340097019103831473349905133558912714201852986162525855145162259280450040753185483478933398530730654529154485769469682628353274080092629445953899362883988215175193630488889635324515092313723195910983168425805177795699565396108348821928449320190783128803002754706992512092839782219348149442008758998793607436136085108333190190347733106486023581643835108125870863346801123024469552193808660738495330000657495372570089643330001020748391509387487524136411478620736071866518379044131693794690230740826475529806050936866355127348429602091123271970724772553111459156824158976033596665391059836828836907988254364980925568575831029223091042575366899359078304670344881979433579570857621141077250931877184312810916773443135402247438937358801349822845162460003198622710136542402567604311023354451215661022609583925197654492145458148760392</span><br><span class="line"></span><br><span class="line">            m = pow(c, d, n)</span><br><span class="line">            decoded_message = long_to_bytes(m).decode(&#x27;utf-8&#x27;, &#x27;ignore&#x27;)</span><br><span class="line"></span><br><span class="line">            if &quot;D0g3&quot; in decoded_message:</span><br><span class="line">                print(decoded_message)</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            continue</span><br><span class="line">#flag：D0g3&#123;sYuWzkFk12A1gcWxG9pymFcjJL7CqN4Cq8PAIACObJ&#125;</span><br></pre></td></tr></table></figure><p>当然赛后也看到了别的师傅更快的方法，但是他们的脚本对笔者的数据并不能跑出结果，<del>官方wp的脚本也跑不了这组数据</del>所以此题存在运气成分<br><del>羡慕会写脚本</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from tqdm import *</span><br><span class="line"></span><br><span class="line">n=</span><br><span class="line">p0=&#x27;&#x27;</span><br><span class="line">c=</span><br><span class="line">def msg(n, p0, c):</span><br><span class="line">    p1 = p0[:1024]</span><br><span class="line">    p2 = p0[1024:]</span><br><span class="line">    pp1 = [i for i, c in enumerate(p1) if c == &#x27;0&#x27;]</span><br><span class="line">    pp2 = [i for i, c in enumerate(p1) if c == &#x27;1&#x27;]</span><br><span class="line">    # print(pp1)</span><br><span class="line">    for i in tqdm(pp1):</span><br><span class="line">        p1 = list(p0[:1024])</span><br><span class="line">        p1[i] = &#x27;1&#x27;</span><br><span class="line">        for j in pp2:</span><br><span class="line">            p2 = list(p0[1024:])</span><br><span class="line">            p2[j] = &#x27;0&#x27;</span><br><span class="line">            ppp = &#x27;&#x27;.join(p1) + &#x27;&#x27;.join(p2)</span><br><span class="line">            ppp2 = int(ppp, 2)</span><br><span class="line">            if n % ppp2 == 0:</span><br><span class="line">                p = ppp2</span><br><span class="line">                print(i, j)</span><br><span class="line">                print(p)</span><br><span class="line">                q = n // p</span><br><span class="line">                d = invert(65537, (p-1)*(q-1))</span><br><span class="line">                m = long_to_bytes(int(pow(c, d, n)))</span><br><span class="line">                if b&#x27;D0g3&#x27; in m:</span><br><span class="line">                    print(m)</span><br><span class="line">                    return</span><br><span class="line">            p2[j] = &quot;1&quot;</span><br><span class="line">        p1[i] = &quot;0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msg(n, p0, c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023强网杯密码复现</title>
      <link href="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%AF%86%E7%A0%81%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>强网杯</p><span id="more"></span><p><strong>not only rsa</strong><br>task</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import bytes_to_long</span><br><span class="line">from secret import flag</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">n = 6249734963373034215610144758924910630356277447014258270888329547267471837899275103421406467763122499270790512099702898939814547982931674247240623063334781529511973585977522269522704997379194673181703247780179146749499072297334876619475914747479522310651303344623434565831770309615574478274456549054332451773452773119453059618433160299319070430295124113199473337940505806777950838270849</span><br><span class="line">e = 641747</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">flag = flag + os.urandom(n.bit_length() // 8 - len(flag) - 1)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">with open(&#x27;out.txt&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    print(f&quot;&#123;n = &#125;&quot;, file=f)</span><br><span class="line">    print(f&quot;&#123;e = &#125;&quot;, file=f)</span><br><span class="line">    print(f&quot;&#123;c = &#125;&quot;, file=f)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 6249734963373034215610144758924910630356277447014258270888329547267471837899275103421406467763122499270790512099702898939814547982931674247240623063334781529511973585977522269522704997379194673181703247780179146749499072297334876619475914747479522310651303344623434565831770309615574478274456549054332451773452773119453059618433160299319070430295124113199473337940505806777950838270849</span><br><span class="line">e = 641747</span><br><span class="line">c = 730024611795626517480532940587152891926416120514706825368440230330259913837764632826884065065554839415540061752397144140563698277864414584568812699048873820551131185796851863064509294123861487954267708318027370912496252338232193619491860340395824180108335802813022066531232025997349683725357024257420090981323217296019482516072036780365510855555146547481407283231721904830868033930943</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目分析：<br>本题可以发现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Diffie-Hellman的公钥加密</title>
      <link href="/2023/12/12/%E5%9F%BA%E4%BA%8EDiffie-Hellman%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/"/>
      <url>/2023/12/12/%E5%9F%BA%E4%BA%8EDiffie-Hellman%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>在那篇划时代的论文《New Directions in Cryptography》中，作者Diffie和Hellman虽然并没有提出一个实际的公钥密码加密算法，但却提出了一个可以在不安全信道中交换密钥的协议，这个密钥交换协议就是基于离散对数难题的。</p><span id="more"></span><p>Diffie-Hellman密钥交换协议︰</p><p>1.首先通信双方Alice和Bob先共享两个公共参数，模数p和Z<del>p</del>​^*^,中的一个原根g。</p><ol><li>Alice本地随机生成一个私钥a，并计算公钥A &#x3D; g^a^，发送A给Bob</li><li>Bob在收到A后，也本地随机生成一个私钥b，并计算公钥B&#x3D;g^b^，发送B给Alice;此外，Bob还可以计算共享密钥k &#x3D; A^b^ &#x3D; g^ab^</li><li>Alice收到Bob发过来的B后，也可以计算共享密钥k &#x3D; B^a^ &#x3D; g^ab^<br>5．至此，密钥交换结束，双方都可以得到一份共享密钥</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
